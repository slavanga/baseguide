@use "sass:math";
@use "sass:map";


/// Micro clearfix
@mixin clearfix {
  &::after {
    content: '';
    display: block;
    clear: both;
  }
}


/// Create an aspect ratio box with optional support for dynamic growing content
///
/// @param {String|List} $ratio ['base'] - Map key of the `$embed-ratios` map or a list formatted as `x by y`
/// @param {Bool} $grow [false] - Enables dynamic growing of the container if true
@mixin aspect-ratio($ratio: 'base', $grow: false) {
  @if (type-of($ratio) == 'string' or type-of($ratio) == 'list') {
    $key: map-get($embed-ratios, $ratio);

    @if $key {
      $ratio: ratio-to-percentage($key);
    }
    @else {
      $ratio: ratio-to-percentage($ratio);
    }
  }
  @else {
    $ratio: percentage($ratio);
  }

  &::before {
    content: '';
    display: block;
    padding-bottom: $ratio;
  }

  @if $grow {
    @include clearfix;

    &::before {
      float: left;
    }
  }
}


/// Old school way of hiding text. Better use sr-only with an additional `<span>`
@mixin text-hide {
  text-indent: 110%;
  white-space: nowrap;
  overflow: hidden;
  color: transparent;
  text-shadow: none;
}

/// Truncate text using ellipsis (single-line)
@mixin text-truncate {
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}

/// Activate hyphenation with fallbacks. Make sure to set the lang attribute on the `<html>` tag.
@mixin text-hyphenate {
  overflow-wrap: break-word;
  word-wrap: break-word;
  hyphens: auto;
}


/// Hide content accessibly
@mixin sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
}

/// Undo styles from sr-only
@mixin sr-only-reset {
  position: static;
  width: auto;
  height: auto;
  overflow: visible;
  clip: auto;
  white-space: inherit;
}

/// Undo styles from sr-only when element is activated or focused
@mixin sr-only-focusable {
  &:active,
  &:focus {
    @include sr-only-reset;
  }
}


/// Beautiful underline with control over text spacing
///
/// @param {String|Color} $color [currentColor] - Color of the underline
/// @param {Number} $distance [0] - Distance from the text
/// @param {Number} $width [100%] - Width of the underline
/// @param {Number} $height [1px] - Thickness of the underline
@mixin underline($color: currentColor, $distance: 0, $width: 100%, $height: 1px) {
  padding-bottom: $distance;
  background-image: linear-gradient($color, $color);
  background-size: $width $height;
  background-position: 0 100%;
  background-repeat: no-repeat;
  text-decoration: none;
}


/// Target HiDPI screens
///
/// @param {Number} $ratio [1.5] - Screen resolution ratio
@mixin hidpi($ratio: 1.5) {
  @media (min-resolution: round($ratio * 96dpi)), (min-resolution: $ratio * 1dppx) {
    @content;
  }
}


/// Scale headings using modular scale
///
/// @param {Number} $scale [$type-scale-base]
/// @param {List} $headings [$headings]
@mixin scale-headings($scale: $type-scale-base, $headings: $headings) {
  $max-scale: 0;
  $sizes: $scale;

  @each $heading in $headings {
    #{$heading} {
      @if (type-of($scale) == 'map') {
        // Replace map values with modular scaled values
        @each $key, $value in $scale {
          $sizes: map-remove($sizes, $key);
          $sizes: map-merge($sizes, ($key: modular-scale($max-scale, $value)));
        }
      }
      @else {
        $sizes: modular-scale($max-scale, $scale);
      }

      @include fluid-calc('font-size', $sizes);
    }

    $max-scale: $max-scale + 1;
  }
}


/// Accessible fade in transition
///
/// @param {Number} $duration [0.15s]
@mixin fade-in($duration: 0.15s) {
  visibility: visible;
  opacity: 1;
  transition: visibility 0s linear 0s, opacity $duration;
}

/// Accessible fade out transition
///
/// @param {Number} $duration [0.15s]
@mixin fade-out($duration: 0.15s) {
  visibility: hidden;
  opacity: 0;
  transition: visibility 0s linear $duration, opacity $duration;
}


/// CSS only triangle icon (adapted from bourbon)
///
/// @param {String} $direction
/// @param {Number} $width
/// @param {Number} $height
/// @param {String|Color} $color [currentColor]
@mixin triangle($direction, $width, $height, $color: currentColor) {
  border-style: solid;
  height: 0;
  width: 0;

  @if $direction == 'up' {
    border-color: transparent transparent $color;
    border-width: 0 math.div($width, 2) $height;
  }
  @else if $direction == 'up-right' {
    border-color: transparent $color transparent transparent;
    border-width: 0 $width $width 0;
  }
  @else if $direction == 'right' {
    border-color: transparent transparent transparent $color;
    border-width: math.div($height, 2) 0 math.div($height, 2) $width;
  }
  @else if $direction == 'down-right' {
    border-color: transparent transparent $color;
    border-width: 0 0 $width $width;
  }
  @else if $direction == 'down' {
    border-color: $color transparent transparent;
    border-width: $height math.div($width, 2) 0;
  }
  @else if $direction == 'down-left' {
    border-color: transparent transparent transparent $color;
    border-width: $width 0 0 $width;
  }
  @else if $direction == 'left' {
    border-color: transparent $color transparent transparent;
    border-width: math.div($height, 2) $width math.div($height, 2) 0;
  }
  @else if $direction == 'up-left' {
    border-color: $color transparent transparent;
    border-width: $width $width 0 0;
  }
}


/// Loop all breakpoints and output `@content`
///
/// @param {Map} $breakpoints [$mq-breakpoints] - Map of breakpoints
/// @param {Bool} $inclusive [true] - Outputs inclusive media queries (only min-width) if true
/// @param {Bool} $mq [true] - Outputs media queries if true
@mixin loop-breakpoints($breakpoints: $mq-breakpoints, $inclusive: true, $mq: true) {
  $breakpoint-keys: map-keys($breakpoints);

  @for $i from 1 through length($breakpoint-keys) {
    $breakpoint: nth($breakpoint-keys, $i) !global;
    $is-first-breakpoint: $breakpoint == nth($breakpoint-keys, 1) !global;
    $is-last-breakpoint: $breakpoint == nth($breakpoint-keys, length($breakpoint-keys)) !global;

    @if $mq {
      @if $inclusive {
        // first breakpoint
        @if $is-first-breakpoint {
          @content;
        }
        // remaining breakpoints
        @else {
          @include mq($breakpoint, $breakpoints: $breakpoints) {
            @content;
          }
        }
      }
      @else {
        // first breakpoint
        @if $is-first-breakpoint {
          @if length($breakpoint-keys) > 1 {
            @include mq($until: nth($breakpoint-keys, $i + 1), $breakpoints: $breakpoints) {
              @content;
            }
          }
          @else {
            @content;
          }
        }
        // last breakpoint
        @else if $is-last-breakpoint {
          @include mq($breakpoint, $breakpoints: $breakpoints) {
            @content;
          }
        }
        // remaining breakpoints
        @else {
          @include mq($breakpoint, nth($breakpoint-keys, $i + 1), $breakpoints: $breakpoints) {
            @content;
          }
        }
      }
    }
    @else {
      @content;
    }
  }
}


/// Output content in a media query excluding the first breakpoint
///
/// @param {String} $breakpoint - Named breakpoint key of `$mq-breakpoints`
@mixin skip-first-breakpoint($breakpoint) {
  @if ($breakpoint == nth(map-keys($mq-breakpoints), 1)) {
    @content;
  }
  @else {
    @include mq($breakpoint) {
      @content;
    }
  }
}


/// Generate min, max and fluid in-between values for a given CSS property
///
/// @param {String} $prop - Any CSS property that supports calc as a value
/// @param {Map|Number|List} $sizes - Map of two sizes formatted as (min: x, max y), list of two sizes formatted as (x, y) or a single number for min size
/// @param {Map} $breakpoints [$fluid-breakpoints] - Map of two named breakpoints from `$mq-breakpoints` formatted as (min: md, max: lg) or custom px values formatted as (min: 600px, max: 900px)
/// @param {Bool} $negative [false] - Negates the values if true
/// @param {Bool} $important [false] - Adds important flag if true
/// @param {String} $current-breakpoint [null]
/// @param {List} $all-breakpoints [null]
@mixin fluid-calc($prop, $sizes, $breakpoints: $fluid-breakpoints, $negative: false, $important: false, $current-breakpoint: null, $all-breakpoints: null) {
  $min-size: null;
  $max-size: null;
  $min-breakpoint: map-get($breakpoints, 'min');
  $max-breakpoint: map-get($breakpoints, 'max');
  $min-breakpoint-value: $min-breakpoint;
  $max-breakpoint-value: $max-breakpoint;
  $multiplicand: 1;

  @if (type-of($sizes) == 'map') {
    $min-size: map-get($sizes, 'min');
    $max-size: map-get($sizes, 'max');
  }
  @else if (type-of($sizes) == 'list') {
    $min-size: nth($sizes, 1);
    $max-size: nth($sizes, 2);
  }
  @else if (type-of($sizes) == 'number') {
    $min-size: $sizes;
  }

  @if map-has-key($mq-breakpoints, $min-breakpoint) {
    $min-breakpoint-value: map-get($mq-breakpoints, $min-breakpoint);
  }

  @if map-has-key($mq-breakpoints, $max-breakpoint) {
    $max-breakpoint-value: map-get($mq-breakpoints, $max-breakpoint);
  }

  @if $negative == true {
    $multiplicand: -1;
  }

  @if $important == true {
    $important: unquote('!important');
  }
  @else {
    $important: null;
  }

  @if $min-size {
    $min-size: to-rem($min-size);

    @if (
      not $current-breakpoint
      or $current-breakpoint == nth($all-breakpoints, 1)
      or $current-breakpoint == nth($all-breakpoints, length($all-breakpoints)) and not $max-size
    ) {
      #{$prop}: $min-size * $multiplicand $important;
    }

    @if $max-size and $max-breakpoint-value {
      $max-size: to-rem($max-size);

      @if $fluid-scaling and $min-breakpoint-value {
        $value: calc((#{$min-size} + #{strip-unit($max-size - $min-size)} * (100vw - #{to-rem($min-breakpoint-value)}) / #{strip-unit(to-rem($max-breakpoint-value) - to-rem($min-breakpoint-value))}) * #{$multiplicand}) $important;

        @if ($current-breakpoint) {
          // Breakpoint set already in parent mixin (loop-config)
          #{$prop}: $value;
        }
        @else {
          @include mq($min-breakpoint-value) {
            #{$prop}: $value;
          }
        }
      }

      @if (
        not $current-breakpoint
        or $current-breakpoint == nth($all-breakpoints, length($all-breakpoints))
      ) {
        @include mq($max-breakpoint-value) {
          #{$prop}: $max-size * $multiplicand $important;
        }
      }
    }
  }
}


/// Helper mixin for fluid-calc and config-variation
///
/// @param {Map|Number|List|String} $sizes - Map key of `$spacings`, map of two sizes formatted as (min: x, max y), list of two sizes formatted as (x, y) or a single number for min size
/// @param {String} $prop [null] - Any CSS property that supports calc as a value
/// @param {Bool} $negative [false] - Negates the values if true
/// @param {Bool} $important [false] - Adds important flag if true
@mixin loop-config($sizes, $prop: null, $negative: false, $important: false) {
  @each $key, $value in $sizes {
    @if (map-has-key($mq-breakpoints, $key)) {
      $breakpoint-keys: map-keys($sizes);
      $next-breakpoint: breakpoint-next($key, $breakpoint-keys) or map-get($fluid-breakpoints, 'max');
      $breakpoint-range: (min: $key, max: $next-breakpoint);

      @include skip-first-breakpoint($key) {
        @if (is-sizing-map($value)) {
          @include fluid-calc($prop, $value, $breakpoint-range, $negative, $important, $current-breakpoint: $key, $all-breakpoints: $breakpoint-keys);
        }
        @else {
          @each $deep-key, $deep-value in $value {
            @if (is-sizing-map($deep-value)) {
              @include fluid-calc($deep-key, $deep-value, $breakpoint-range, $negative, $important, $current-breakpoint: $key, $all-breakpoints: $breakpoint-keys);
            }
            @else {
              @include output-props($deep-key, $deep-value);
            }
          }
        }
      }
    }
    @else {
      @include output-props($key, $value);
    }
  }
}


/// Utility mixin for `config-variation` mixin
///
/// @param {String} $key
/// @param {String|Number|Color|Map} $value
@mixin output-props($key, $value) {
  @if (index(('hover', 'focus', 'active'), $key)) {
    &:#{$key} {
      @each $pseudo-key, $pseudo-value in $value {
        #{$pseudo-key}: $pseudo-value;
      }
    }
  }
  @else if (index(('before', 'after'), $key)) {
    &::#{$key} {
      @each $pseudo-key, $pseudo-value in $value {
        #{$pseudo-key}: $pseudo-value;
      }
    }
  }
  @else if ($key == 'disabled') {
    &:disabled,
    &.disabled {
      @each $disabled-key, $disabled-value in $value {
        #{$disabled-key}: $disabled-value;
      }
    }
  }
  @else if (is-sizing-map($value)) {
    @include fluid-calc($key, $value);
  }
  @else {
    #{$key}: $value;
  }
}


/// Wrapper mixin for fluid-calc that gets spacings from the map `$spacings`
///
/// @param {String} $prop - Any CSS property that supports calc as a value
/// @param {Map|Number|List|String} $sizes - Map key of `$spacings`, map of two sizes formatted as (min: x, max y), list of two sizes formatted as (x, y) or a single number for min size
/// @param {Map} $breakpoints - Map of two named breakpoints from `$mq-breakpoints` formatted as (md, lg) or custom px values formatted as (min: 600px, max: 900px)
/// @param {Bool} $negative [false] - Negates the values if true
/// @param {Bool} $important [false] - Adds important flag if true
@mixin fluid-spacing($prop, $sizes: 'base', $negative: false, $important: false) {
  @if (type-of($sizes) == 'string') {
    $spacings-size: map-get($spacings, $sizes);

    @if $spacings-size {
      $sizes: $spacings-size;
    }
    @else {
      @error "The spacing `#{$sizes}` wasn't found in map $spacings.";
    }
  }

  // If we have a map of named breakpoints
  @if (
    type-of($sizes) == 'map'
    and map-has-key($mq-breakpoints, nth(map-keys($sizes), 1))
  ) {
    @include loop-config($sizes, $prop, $negative: $negative, $important: $important);
  }
  @else {
    @include fluid-calc($prop, $sizes, $negative: $negative, $important: $important);
  }
}


/// Generate config variations (e.g buttons or type)
///
/// @param {Map} $variation-map
/// @param {String} $variation
@mixin config-variation($variation-map, $variation) {
  $config: map-get($variation-map, $variation);

  @if not $config {
    @error "The key `#{$variation}` wasn't found in map $variation-map.";
  }

  @include loop-config($config);
}


/// Wrapper mixin for config-variation that uses the `$type-variations` map as default lookup map
///
/// @param {String} $variation ['base'] - Map key of `$type-variations`
@mixin type($variation: 'base') {
  @include config-variation($type-variations, $variation);
}
